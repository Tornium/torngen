defmodule Torngen.Client.Schema.<%= schema.reference %> do
  @moduledoc """
  [SHORT DESCRIPTION]
  """

  use Torngen.Client.SchemaObjectAccess, deprecated: [<%= for pair <- schema.pairs do %><%= if pair.deprecated do %>:<%= pair.key |> Torngen.Generator.Elixir.normalize_string() %>,<% end %><% end %>]

  @behaviour Torngen.Client.Schema

  @keys [<%= for pair <- schema.pairs do %>:<%= pair.key |> Torngen.Generator.Elixir.normalize_string() %>,<% end %>]

  defstruct [<%= for pair <- schema.pairs do %>
    :<%= pair.key |> Torngen.Generator.Elixir.normalize_string() %>,<% end %>
  ]

  @type t :: %__MODULE__{<%= for pair <- schema.pairs do %>
    <%= pair.key |> Torngen.Generator.Elixir.normalize_string() %>: <%= Torngen.Generator.Elixir.Schema.resolve_type(pair.value, spec) %>,<% end %>
  }

  @impl true
  def parse(%{} = data) do
    %__MODULE__{<%= for pair <- schema.pairs do %><%= if not String.contains?(pair.key, "-") do %>
      <%= pair.key |> Torngen.Generator.Elixir.normalize_string() %>: data |> Map.get("<%= pair.key %>") |> Torngen.Client.Schema.parse(<%= Torngen.Generator.Elixir.repr(spec, pair.value) |> inspect() %>),<% end %><% end %>
    }
  end

  @impl true
  def validate?(%{} = data) do
    @keys
    |> Enum.map(fn key -> {key, Map.get(data, Atom.to_string(key))} end)
    |> Enum.map(fn {key, value} -> validate_key?(key, value) end)
    |> Enum.all?()
  end

  <%= for pair <- schema.pairs do %>
  defp validate_key?(:<%= pair.key |> Torngen.Generator.Elixir.normalize_string() %>, value) do
    Torngen.Client.Schema.validate?(value, <%= Torngen.Generator.Elixir.repr(spec, pair.value) |> inspect() %> )
  end
  <% end %>

  @spec keys() :: list(atom())
  def keys(), do: @keys
end
